"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = exports.instantiate = exports.storeCode = exports.optimize = exports.build = void 0;
const tslib_1 = require("tslib");
/* eslint-disable no-await-in-loop */
const os_1 = tslib_1.__importDefault(require("os"));
const terra_js_1 = require("@terra-money/terra.js");
const toml_1 = require("toml");
const child_process_1 = require("child_process");
const fs = tslib_1.__importStar(require("fs-extra"));
const cli_ux_1 = require("cli-ux");
const YAML = tslib_1.__importStar(require("yaml"));
const path_1 = tslib_1.__importDefault(require("path"));
const config_1 = require("../config");
const TerrainCLI_1 = tslib_1.__importDefault(require("../TerrainCLI"));
const useARM64_1 = tslib_1.__importDefault(require("./useARM64"));
exports.build = async ({ contract }) => {
    const startingDirectory = process.cwd();
    const folder = path_1.default.join('contracts', contract);
    process.chdir(folder);
    const { package: pkg } = toml_1.parse(fs.readFileSync('./Cargo.toml', 'utf-8'));
    if (contract !== pkg.name) {
        cli_ux_1.cli.error(`Change the package name in Cargo.toml to ${contract} to build`);
    }
    child_process_1.execSync('cargo wasm', { stdio: 'inherit' });
    process.chdir(startingDirectory);
};
const execDockerOptimization = (image, cache) => {
    const dir = os_1.default.platform() === 'win32' ? '%cd%' : '$(pwd)';
    child_process_1.execSync(`docker run --rm -v "${dir}":/code \
      --mount type=volume,source="${cache}_cache",target=/code/target \
      --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
      ${image}`, { stdio: 'inherit' });
};
const optimizeContract = async ({ contract, arm64, }) => {
    const startingDirectory = process.cwd();
    const folder = path_1.default.join('contracts', contract);
    process.chdir(folder);
    const image = `cosmwasm/rust-optimizer${arm64 ? '-arm64' : ''}:0.12.6`;
    execDockerOptimization(image, contract);
    process.chdir(startingDirectory);
};
const optimizeWorkspace = async ({ contract, arm64, }) => {
    const image = `cosmwasm/workspace-optimizer${arm64 ? '-arm64' : ''}:0.12.6`;
    execDockerOptimization(image, contract);
};
exports.optimize = async ({ contract, useCargoWorkspace, network, }) => {
    const arm64 = useARM64_1.default(network);
    if (useCargoWorkspace) {
        optimizeWorkspace({ contract, arm64 });
    }
    else {
        optimizeContract({ contract, arm64 });
    }
};
exports.storeCode = async ({ contract, signer, network, refsPath, lcd, codeId, noRebuild, useCargoWorkspace, }) => {
    const arm64 = useARM64_1.default(network);
    if (!noRebuild) {
        await exports.build({ contract });
        await exports.optimize({ contract, useCargoWorkspace, network });
    }
    let wasmByteCodeFilename = `${contract.replace(/-/g, '_')}`;
    // rust-optimizer-arm64 produces a file with the `-aarch64` suffix.
    if (arm64) {
        wasmByteCodeFilename += '-aarch64';
    }
    wasmByteCodeFilename += '.wasm';
    // Check if user is attempting to store ARM64 wasm binary on mainnet.
    const wasmFiles = fs.readdirSync(path_1.default.join('contracts', contract, 'artifacts'));
    const storingARM64Mainnet = (!wasmFiles.includes(wasmByteCodeFilename)
        && process.arch === 'arm64'
        && network === 'mainnet');
    // Check if user is attempting to store ARM64 type wasm on mainnet.
    // If so, reoptimize to default wasm binary to store on mainnet.
    if (storingARM64Mainnet) {
        TerrainCLI_1.default.alert(`
ARM64 wasm files should not be stored on mainnet.\n
Rebuilding contract to deploy default wasm binary.
    `, 'ðŸš¨ ARM64 Wasm Detected ðŸš¨');
        await exports.optimize({ contract, useCargoWorkspace, network });
    }
    const artifactFileName = useCargoWorkspace
        ? path_1.default.join('artifacts', wasmByteCodeFilename)
        : path_1.default.join('contracts', contract, 'artifacts', wasmByteCodeFilename);
    const wasmByteCode = fs.readFileSync(artifactFileName).toString('base64');
    cli_ux_1.cli.action.start('storing wasm bytecode on chain');
    const storeCodeTx = await signer.createAndSignTx({
        msgs: [
            typeof codeId !== 'undefined'
                ? new terra_js_1.MsgMigrateCode(signer.key.accAddress, codeId, wasmByteCode)
                : new terra_js_1.MsgStoreCode(signer.key.accAddress, wasmByteCode),
        ],
    });
    const res = await lcd.tx.broadcast(storeCodeTx);
    try {
        const savedCodeId = JSON.parse((res && res.raw_log) || '')[0]
            .events.find((msg) => msg.type === 'store_code')
            .attributes.find((attr) => attr.key === 'code_id').value;
        const updatedRefs = config_1.setCodeId(network, contract, savedCodeId)(config_1.loadRefs(refsPath));
        config_1.saveRefs(updatedRefs, refsPath);
        cli_ux_1.cli.log(`code is stored at code id: ${savedCodeId}`);
        return savedCodeId;
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            cli_ux_1.cli.error(res.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpected Error: ${error}`);
        }
    }
    return undefined;
};
exports.instantiate = async ({ conf, refsPath, network, lcd, signer, admin, contract, codeId, instanceId, sequence, }) => {
    var _a;
    const { instantiation } = conf;
    const actualCodeId = codeId || config_1.loadRefs(refsPath)[network][contract].codeId;
    cli_ux_1.cli.action.start(`instantiating contract with msg: ${JSON.stringify(instantiation.instantiateMsg)}`);
    // Allow manual account sequences.
    const manualSequence = sequence || (await signer.sequence());
    // Create signerData and txOptions for fee estimation.
    const accountInfo = await lcd.auth.accountInfo(signer.key.accAddress);
    const signerData = [
        {
            sequenceNumber: manualSequence,
            publicKey: accountInfo.getPublicKey(),
        },
    ];
    const txOptions = {
        msgs: [
            new terra_js_1.MsgInstantiateContract(signer.key.accAddress, admin, // can migrate
            actualCodeId, instantiation.instantiateMsg, undefined, 'Instantiate'),
        ],
    };
    // Set default terraDenom and feeDenoms value if not specified.
    if (!txOptions.feeDenoms) {
        txOptions.feeDenoms = ['uluna'];
    }
    const terraDenom = 'LUNA';
    // Prompt user to accept gas fee for contract initialization if network is mainnet.
    if (network === 'mainnet') {
        const feeEstimate = await lcd.tx.estimateFee(signerData, txOptions);
        const gasFee = Number(feeEstimate.amount.get(txOptions.feeDenoms[0]).amount) / 1000000;
        await TerrainCLI_1.default.anykey(`The gas needed to deploy the '${contract}' contact is estimated to be ${gasFee} ${terraDenom}. Press any key to continue or "ctl+c" to exit`);
    }
    const instantiateTx = await signer.createAndSignTx(Object.assign({ sequence: manualSequence }, txOptions));
    const res = await lcd.tx.broadcast(instantiateTx);
    let log = [];
    try {
        log = JSON.parse(res.raw_log);
    }
    catch (error) {
        cli_ux_1.cli.action.stop();
        if (error instanceof SyntaxError && res) {
            cli_ux_1.cli.error(res.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpected Error: ${error}`);
        }
    }
    cli_ux_1.cli.action.stop();
    const event = (_a = log[0].events.find((e) => e.type === 'instantiate_contract')) !== null && _a !== void 0 ? _a : log[0].events.find((e) => e.type === 'instantiate');
    const contractAddress = event.attributes.find((attr) => attr.key === '_contract_address').value;
    const updatedRefs = config_1.setContractAddress(network, contract, instanceId || 'default', contractAddress)(config_1.loadRefs(refsPath));
    config_1.saveRefs(updatedRefs, refsPath);
    cli_ux_1.cli.log(YAML.stringify(log));
    return contractAddress;
};
exports.migrate = async ({ conf, refsPath, lcd, signer, contract, codeId, network, instanceId, }) => {
    const { instantiation } = conf;
    const refs = config_1.loadRefs(refsPath);
    const contractAddress = refs[network][contract].contractAddresses[instanceId];
    cli_ux_1.cli.action.start(`migrating contract with address ${contractAddress} to code id: ${codeId}`);
    const migrateTx = await signer.createAndSignTx({
        msgs: [
            new terra_js_1.MsgMigrateContract(signer.key.accAddress, contractAddress, codeId, instantiation.instantiateMsg),
        ],
    });
    const resInstant = await lcd.tx.broadcast(migrateTx);
    let log = [];
    try {
        log = JSON.parse(resInstant.raw_log);
    }
    catch (error) {
        cli_ux_1.cli.action.stop();
        if (error instanceof SyntaxError) {
            cli_ux_1.cli.error(resInstant.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpected Error: ${error}`);
        }
    }
    cli_ux_1.cli.action.stop();
    const updatedRefs = config_1.setContractAddress(network, contract, instanceId, contractAddress)(config_1.loadRefs(refsPath));
    config_1.saveRefs(updatedRefs, refsPath);
    cli_ux_1.cli.log(YAML.stringify(log));
};
