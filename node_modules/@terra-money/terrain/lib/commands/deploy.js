"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const terra_js_1 = require("@terra-money/terra.js");
const config_1 = require("../config");
const deployment_1 = require("../lib/deployment");
const signer_1 = require("../lib/signer");
const flag = tslib_1.__importStar(require("../lib/flag"));
class Deploy extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Deploy);
        const connections = config_1.loadConnections(flags['config-path']);
        const config = config_1.loadConfig(flags['config-path']);
        const globalConfig = config_1.loadGlobalConfig(flags['config-path']);
        const conf = config(flags.network, args.contract);
        // @ts-ignore
        const lcd = new terra_js_1.LCDClient(connections(flags.network));
        const signer = signer_1.getSigner({
            network: flags.network,
            signerId: flags.signer,
            keysPath: flags['keys-path'],
            lcd,
        });
        if (conf.deployTask) {
            await this.config.runCommand('task:run', [
                conf.deployTask,
                '--signer',
                flags.signer,
                '--network',
                flags.network,
                '--refs-path',
                flags['refs-path'],
                '--config-path',
                flags['config-path'],
                '--keys-path',
                flags['keys-path'],
            ]);
        }
        else {
            // Store sequence to manually increment after code is stored.
            const sequence = await signer.sequence();
            const codeId = await deployment_1.storeCode({
                lcd,
                conf,
                signer,
                noRebuild: flags['no-rebuild'],
                contract: args.contract,
                network: flags.network,
                refsPath: flags['refs-path'],
                useCargoWorkspace: globalConfig.useCargoWorkspace,
            });
            // pause for account sequence to update.
            // eslint-disable-next-line no-promise-executor-return
            await new Promise((r) => setTimeout(r, 1000));
            const admin = flags['admin-address']
                ? flags['admin-address']
                : signer.key.accAddress;
            await deployment_1.instantiate({
                conf,
                signer,
                admin,
                sequence: 1 + sequence,
                contract: args.contract,
                codeId,
                network: flags.network,
                instanceId: flags['instance-id'],
                refsPath: flags['refs-path'],
                lcd,
            });
        }
        await this.config.runCommand('contract:generateClient', [
            args.contract,
            '--build-schema',
        ]);
        if (!flags['no-sync']) {
            await this.config.runCommand('sync-refs', [
                '--refs-path',
                flags['refs-path'],
                '--dest',
                flags['frontend-refs-path'],
            ]);
        }
    }
}
exports.default = Deploy;
Deploy.description = 'Build wasm bytecode, store code on chain and instantiate.';
Deploy.flags = Object.assign({ signer: flag.signer, network: flag.network, 'no-rebuild': flag.noRebuild, 'instance-id': flag.instanceId, 'frontend-refs-path': flag.frontendRefsPath, 'admin-address': command_1.flags.string({
        description: 'set custom address as contract admin to allow migration.',
    }), 'no-sync': command_1.flags.string({
        description: 'don\'t attempt to sync contract refs to frontend.',
    }) }, flag.terrainPaths);
Deploy.args = [{ name: 'contract', required: true }];
